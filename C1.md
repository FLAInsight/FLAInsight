# Title

(C1) Reentrancy Vulnerabilities Exploited By Flash Loan Attacks

## Relationships

[1] [SWC-107: Reentrancy](https://swcregistry.io/docs/SWC-107/)

## Sample

### Incident

> [2021/12/19] Grim Finance Attack: https://learnblockchain.cn/article/3628

### Code

>  https://ftmscan.com/address/0x660184ce8af80e0b1e5a1172a16168b15f4136bf

#### Vulnerable Code Snippet

```solidity
1     function depositFor(address token, uint _amount,address user ) public {
2 
3         uint256 _pool = balance();
4         IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);
5         earn();
6         uint256 _after = balance();
7         _amount = _after.sub(_pool); // Additional check for deflationary tokens
8         uint256 shares = 0;
9         if (totalSupply() == 0) {
10            shares = _amount;
11        } else {
12            shares = (_amount.mul(totalSupply())).div(_pool);
13        }
14        _mint(user, shares);
15    }
```

#### Attack Process
Traditional reentrancy usually refers to the pattern of ``check balance ï¼ˆChecks) - transfer call (Interactions) - change balance (Effects)`` (SWC-107). Consequently, [existing best practices](https://docs.soliditylang.org/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) recommend delaying ``Interactions`` after ``Effects``. 

However, in this incident, the code example exhibits the pattern ``collateralize (Interactions) - change shares (Effects) - obtain certificate (Interactions)``. The attack takes advantage of reentrancy in the initial interaction and profits from the final interaction. 

Therefore, although flash loan attacks leverage known vulnerabilities, the context of the affected contracts and the attack processes are more complex and diverse, which may surpass the detection capabilities of current tools.



